<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Michael N. Zietz" />
  <meta name="date" content="2017-08-25" />
  <meta name="keywords" content="work-in-progress, markdown, manuscript, publishing" />
  <title>Vagelos Report Summer 2017</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="github-pandoc.css" type="text/css" />
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!-- Insert Analytics Script Below -->
  <script>
  </script>
  <!-- End Analytics Script -->
</head>
<body>
<div id="header">
<h1 class="title">Vagelos Report Summer 2017</h1>
</div>
<p><em>This report is available online at <a href="https://doi.org/10.6084/m9.figshare.5346577" class="uri">https://doi.org/10.6084/m9.figshare.5346577</a>.</em></p>
<p><small><em> This manuscript was automatically generated from <a href="https://github.com/zietzm/Vagelos2017/tree/5c827bdf169c6f8ecee8f1703596da44dba5c3b1">zietzm/Vagelos2017@5c827bd</a> on August 25, 2017. </em></small></p>
<h2 id="authors">Authors</h2>
<ul>
<li><strong>Michael N. Zietz</strong><br> <img src="images/orcid.svg" alt="ORCID icon" height="13" /> <a href="https://orcid.org/0000-0003-0539-630X">0000-0003-0539-630X</a> · <img src="images/github.svg" alt="GitHub icon" height="13" /> <a href="https://github.com/zietzm">zietzm</a><br> <small> Greene Lab, Department of Systems Pharmacology and Translational Therapeutics, University of Pennsylvania </small></li>
</ul>
<h2 id="scientific-background">Scientific background</h2>
<h3 id="drug-development">Drug development</h3>
<p>Drug development times and R&amp;D expenditures have risen considerably in the last decades. In fact, to bring a new compound to market can take 14 years on average <span class="citation">[<a href="#ref-LlRXV6lE">1</a>]</span>. This development process, according to a 2016 estimate by DiMasi et al. <span class="citation">[<a href="#ref-13c9OPizf">2</a>]</span>, costs an average of $2.87 billion dollars, including post-approval R&amp;D. This amount is up from two previous studies by the same authors which found the average captialized R&amp;D costs (in inflation-adjusted 2016 dollars) to be $1.06 billion in 2003 <span class="citation">[<a href="#ref-nn9rnuHx">3</a>]</span> and $568 million in 1991 <span class="citation">[<a href="#ref-269zMv7S">4</a>]</span>. Despite increases in drug development time and expenditures, the rate of R&amp;D failure has increased since the 1990s <span class="citation">[<a href="#ref-z38InjRh">5</a>]</span>. Only about one in 5,000 compounds which begin preclinical testing are eventually approved <span class="citation">[<a href="#ref-g5JcTYOY">6</a>]</span>. Even among those which enter phase I of clinical development, only an estimated one in ten drugs will receive FDA approval <span class="citation">[<a href="#ref-o8yROPbx">7</a>]</span>.</p>
<h3 id="drug-repurposing">Drug repurposing</h3>
<p>Drug repurposing refers to the application of an existing therapeutic to a different disease than the one for which it was originally intended. Because candidates for drug repurposing have already been approved for other diseases, the time and cost associated with repurposing a drug are very small compared to the development of a new drug <span class="citation">[<a href="#ref-c7z5BwrM">8</a>]</span>. In fact, even compounds which have been deemed safe but have failed in clinical development for other reasons can be candidates for drug repurposing. Several examples exist of drugs which have been repurposed, for example aspirin to treat coronary artery disease, sildenafil to treat erectile dysfunction, and gabapentin to treat postherpetic neuralgia. Most successfully repurposed drugs were discovered serendipitously and not through any systematic discovery mechanism. Our goal is to make accurate predictions of drugs which are candidates for drug repurposing. We hope to do this using heterogeneous networks of biomedical information to learn the patterns of connections between compounds which treat diseases.</p>
<h2 id="summer-aims">Summer aims</h2>
<p>This summer I worked within the Greene Lab project called ‘Hetmech’ <span class="citation">[<a href="#ref-X1hJHTyw">9</a>]</span>. Hetmech aims to improve upon and expand our existing method for predicting drug repurposing targets.</p>
<p>I had three primary aims for my work this summer. The details of each are covered in the Methods section.</p>
<p>First, I wanted to add a capability within Hetmech to compute precisely the degree-weighted path count (DWPC). Previously, the three options had been an extremely slow DWPC method, an inaccurate DWPC method, and a degree-weighted walk count (DWWC), whose limitations will be covered in the Methods section.</p>
<p>Second, I hoped to decrease the time required to make calculations of DWPC. Towards this aim, I hoped to speed up computation by at least an order of magnitude. Sparse matrices and parallel computation were planned solutions to this problem.</p>
<p>Finally, it was my goal to add a multiple search capability. This involves querying a set of nodes to return a set of predictions for nodes which connect the queried nodes. For example, one should be able to search a set of symptoms and return a list of potential diseases that connect the symptoms. As with the previous problems, moving to strictly matrix computation makes this much more simple.</p>
<p>My secondary aim for the summer was to become familiar with and contribute to open-source, reproducible, computational science in biology. I hoped to contribute to a collaboratively written review of deep learning methods in the fields of biology and medicine <span class="citation">[<a href="#ref-yLr4pV4G">10</a>]</span>.</p>
<h2 id="methods">Methods</h2>
<h3 id="heterogeneous-networks">Heterogeneous networks</h3>
<p>Heterogeneous networks (‘hetnets’) are networks with multiple node types and edge types. In the network used this summer, titled Hetionet v1.0 (Figure <a href="#fig:metagraph">1</a>B), nodes represent instances of 11 biomedical entity types, and edges correspond to one of 24 edge types, or relationships between entities. ‘Graph’ in this context refers to the entire network of nodes and edges. We define ‘metagraph’ to mean a graph of the types of nodes and edges in Hetionet (Figure <a href="#fig:metagraph">1</a>A).</p>
<div class="figure">
<img src="https://raw.githubusercontent.com/zietzm/Vagelos2017/master/content/images/graph_metagraph.png" alt="Figure 1: A. Metagraph. The graph of metandoes (node types) and metaedges (edge types). B. Graph (Hetionet v1.0) The circles and lines represent nodes within the labeled types. For example, within the metanode Anatomy we could have the node Leukocyte." id="fig:metagraph" />
<p class="caption">Figure 1: A. Metagraph. The graph of metandoes (node types) and metaedges (edge types). B. Graph (Hetionet v1.0) The circles and lines represent nodes <em>within</em> the labeled types. For example, within the metanode ‘Anatomy’ we could have the node ‘Leukocyte’.</p>
</div>
<p>Hetionet v1.0 incorporated 47,031 nodes and 2,250,197 edges <span class="citation">[<a href="#ref-11rVTcUCK">11</a>]</span>. A further breakdown of the nodes and edges can be found below in Tables <a href="#tbl:nodes-by-type">1</a> and <a href="#tbl:nodes-by-source">2</a>, respectively.</p>
<a name="tbl:nodes-by-type"></a>
<table>
<caption>Table 1: Breakdown of nodes by type </caption>
<thead>
<tr class="header">
<th>Metanode</th>
<th>Nodes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Anatomy</td>
<td>402</td>
</tr>
<tr class="even">
<td>Biological Process</td>
<td>11,381</td>
</tr>
<tr class="odd">
<td>Cellular Component</td>
<td>1,391</td>
</tr>
<tr class="even">
<td>Compound</td>
<td>1,552</td>
</tr>
<tr class="odd">
<td>Disease</td>
<td>137</td>
</tr>
<tr class="even">
<td>Gene</td>
<td>20,945</td>
</tr>
<tr class="odd">
<td>Molecular Function</td>
<td>2,884</td>
</tr>
<tr class="even">
<td>Pathway</td>
<td>1,822</td>
</tr>
<tr class="odd">
<td>Pharmacologic Class</td>
<td>345</td>
</tr>
<tr class="even">
<td>Side Effect</td>
<td>5,734</td>
</tr>
<tr class="odd">
<td>Symptom</td>
<td>438</td>
</tr>
</tbody>
</table>
<a name="tbl:nodes-by-source"></a>
<table>
<caption>Table 2: Breakdown of edges by type and data source </caption>
<thead>
<tr class="header">
<th>Metaedge</th>
<th>Edges</th>
<th>Source</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Anatomy-downregulates-Gene</td>
<td>102,240</td>
<td>Bgee</td>
</tr>
<tr class="even">
<td>Anatomy-expresses-Gene</td>
<td>526,407</td>
<td>Bgee and TISSUES</td>
</tr>
<tr class="odd">
<td>Anatomy-upregulates-Gene</td>
<td>97,848</td>
<td>Bgee</td>
</tr>
<tr class="even">
<td>Compound-binds-Gene</td>
<td>11,571</td>
<td>BindingDB, DrugBank, DrugCentral</td>
</tr>
<tr class="odd">
<td>Compound-causes-Side Effect</td>
<td>138,944</td>
<td>SIDER</td>
</tr>
<tr class="even">
<td>Compound-downregulates-Gene</td>
<td>21,102</td>
<td>LINCS L1000</td>
</tr>
<tr class="odd">
<td>Compound-palliates-Disease</td>
<td>390</td>
<td>PharmacotherapyDB</td>
</tr>
<tr class="even">
<td>Compound-resembles-Compound</td>
<td>6,486</td>
<td>Dice coefficient = 0.5</td>
</tr>
<tr class="odd">
<td>Compound-treats-Disease</td>
<td>755</td>
<td>PharmacotherapyDB</td>
</tr>
<tr class="even">
<td>Compound-upregulates-Gene</td>
<td>18,756</td>
<td>LINCS L1000</td>
</tr>
<tr class="odd">
<td>Disease-associates-Gene</td>
<td>12,623</td>
<td>GWAS Catalog, DISEASES, DisGeNET, DOAF</td>
</tr>
<tr class="even">
<td>Disease-downregulates-Gene</td>
<td>7,623</td>
<td>STARGEO</td>
</tr>
<tr class="odd">
<td>Disease-localizes-Anatomy</td>
<td>3,602</td>
<td>MEDLINE</td>
</tr>
<tr class="even">
<td>Disease-presents-Symptom</td>
<td>3,357</td>
<td>MEDLINE</td>
</tr>
<tr class="odd">
<td>Disease-resembles-Disease</td>
<td>543</td>
<td>MEDLINE</td>
</tr>
<tr class="even">
<td>Disease-upregulates-Gene</td>
<td>7,731</td>
<td>STARGEO</td>
</tr>
<tr class="odd">
<td>Gene-covaries-Gene</td>
<td>61,690</td>
<td>Evolutionary rate covariation = 0.75</td>
</tr>
<tr class="even">
<td>Gene-interacts-Gene</td>
<td>147,164</td>
<td>Evolutionary rate covariation = 0.75</td>
</tr>
<tr class="odd">
<td>Gene-participates-Biological Process</td>
<td>559,504</td>
<td>Gene Ontology</td>
</tr>
<tr class="even">
<td>Gene-participates-Cellular Component</td>
<td>73,566</td>
<td>Gene Ontology</td>
</tr>
<tr class="odd">
<td>Gene-participates-Molecular Function</td>
<td>97,222</td>
<td>Gene Ontology</td>
</tr>
<tr class="even">
<td>Gene-participates-Pathway</td>
<td>84,372</td>
<td>Gene Ontology</td>
</tr>
<tr class="odd">
<td>Gene-regulates-Gene</td>
<td>265,672</td>
<td>Gene Ontology</td>
</tr>
<tr class="even">
<td>Pharmacologic Class-includes-Compound</td>
<td>1,029</td>
<td>DrugCentral</td>
</tr>
</tbody>
</table>
<h3 id="graph-analysis">Graph analysis</h3>
<p>An adjacency matrix refers to a labeled matrix with 1 or 0 at every position, corresponding to the presence or absence of a connection between two nodes <span class="citation">[<a href="#ref-w4Mi034s">12</a>]</span>. The matrix is labeled, meaning that each row and column correspond to a source and target node, respectively. A function was created, titled <code>metaedge_to_adjacency_matrix</code> which performed the conversion from a string metaedge, such as ‘DaG’, to an adjacency matrix.</p>
<div class="figure">
<img src="images/graph.svg" alt="Figure 2: An example graph. Blue nodes are genes, while green nodes are diseases. The edge type between all the nodes in this graph is DaG or Disease-associates-Gene. This is also the complete graph for the relationship DaGaD starting with spinal cancer." id="fig:eg_graph" width="480" />
<p class="caption">Figure 2: An example graph. Blue nodes are genes, while green nodes are diseases. The edge type between all the nodes in this graph is ‘DaG’ or ‘Disease-associates-Gene’. This is also the complete graph for the relationship ‘DaGaD’ starting with ‘spinal cancer’.</p>
</div>
<p>For example, the graph in Figure <a href="#fig:eg_graph">2</a> has the following adjacency matrix corresponding to ‘GaD’:</p>
<p><span class="math display">\[
\begin{equation}
\begin{bmatrix}
1 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1
\end{bmatrix}
\end{equation}
\]</span></p>
<p>with labels for rows and columns, respectively:</p>
<span class="math display">\[\begin{bmatrix}
\textrm{NF2}\\
\textrm{NRXN2}\\
\textrm{SMARCE1}
\end{bmatrix}\]</span>
<span class="math display">\[\begin{bmatrix}
\textrm{epilepsy syndrome}\\
\textrm{kidney cancer}\\
\textrm{pancreatic cancer}\\
\textrm{spinal cancer}\\
\textrm{malignant mesothelioma}\\
\textrm{peripheral nervous system neoplasm}\\
\textrm{autistic disorder}\\
\textrm{meningioma}\\
\textrm{salivary gland cancer}
\end{bmatrix}\]</span>
<p>An adjacency matrix is identical to the information about connections between nodes along a given metaedge. Another way to consider an adjacency matrix is as a list of the nodes at which one can arrive in one step from a given start node. In this sense, performing a matrix multiplication with two adjacency matrices gives the nodes at which one can arrive in exactly <em>two</em> steps. Further, an arbitrary number of multiplications can be performed between adjacency matrices corresponding to various metaedges, so long as the dimensionality is appropriate to the matrix multiplication in question. Using this method, we can extract what is known as a walk count, or the number of ways to traverse the graph between two nodes. In this way of thinking, an adjacency matrix corresponds to the path count for paths of length one. Using the graph in Figure <a href="#fig:eg_graph">2</a>, we could perform a traversal along the meta<em>path</em> ‘GaDaG’, and would obtain the following matrix:</p>
<span class="math display">\[\begin{bmatrix}
6 &amp; 1 &amp; 2\\
1 &amp; 3 &amp; 1\\
2 &amp; 1 &amp; 3
\end{bmatrix}\]</span>
<p>Notice that the elements along the main diagonal of the above matrix are not zero. This indicates that we are accounting for walks in which we traverse the nodes as follows: ‘NF2’ ⟶ ‘kidney cancer’ ⟶ ‘NF2’. Looping walks do not provide useful information, and they introduce considerable noise in measures of connection between nodes. We therefore wanted to eliminate any usage of walk count and replace it with path count, where a path is a type of walk which <em>cannot</em> loop backwards on itself. In this example and for paths of length two, this is trivial; we simply subtract the main diagonal, and we have converted from a walk count to a path count. However, this conversion becomes non-trivial when dealing with longer paths and overlapping metanode repeats. Using the graph in Figure <a href="#fig:eg_graph">2</a>, <em>NF2—associates—spinal cancer—resembles—peripheral nervous system neoplasm—associates—NF2</em> is considered a walk, but it is not a path because its start and end nodes are the same. Note that it is perfectly acceptable to repeat <em>metanodes</em>, meaning that we can have metapaths of the form ‘CrCrCrC’. Paths simply exclude the repeat of <em>specific nodes</em> within an ordering of nodes.</p>
<p>Path counts provide useful information for predicting potential new relationships within a graph. Higher path-counts between two nodes shows good performance as a feature for predicting novel connections <span class="citation">[<a href="#ref-WkPlH1ds">13</a>]</span>. However, as high-degree nodes by definition make many connections, superior performance was achieved by downweighting nodes according to their degree. To do this, row sums and column sums are taken for a matrix at each step. These one-dimensional arrays are exponentiated by a damping exponent, and the matrix is multiplied by each array (vector). This represents the ‘degree-weight’ portion of the ‘degree-weighted path count’. My work toward this will be further discussed in the Results section.</p>
<p>Once we have calculated the DWPC over all the considered metapaths, we use the best of these path counts as features to train a machine learning (logistic regression) model. Once trained, the model’s performance is assessed by comparing its predictions to known relationships. Since we cannot exclude test paths from the overall network, however, we must compare each feature’s performance to its performance on a ‘permuted hetnet’, or an identical network in which the edges have been randomly reassigned, while node-degree has been universally preserved. The corrected measure we use to assess feature performance is therefore the ΔAUROC, the difference in area under (AU) the receiver operating characteristic (ROC) curve. Once our model is trained and tested, we can translate DWPC data for specific connections into the probability that a compound treats a disease.</p>
<h3 id="computational-tools">Computational tools</h3>
<p>All computational work was done in Python version 3.6. We used an open-source Conda environment to manage packages and dependencies for Python.</p>
<h4 id="matrices">Matrices</h4>
<p>Python’s mathematical and array library, NumPy <span class="citation">[<a href="#ref-eye5ay6P">14</a>]</span>, has an n-dimensional array class called an <code>ndarray</code>. <code>numpy.ndarray</code>s are very useful for representing matrix information, and have superior functionality for our purposes than the native <code>numpy.matrix</code> class. However, as can be seen in Table <a href="#tbl:nodes-by-type">1</a>, the number of nodes in a given adjacency matrix can be upwards of 20,000. In performing matrix multiplications, this can become a computation-intensive process that requires both significant CPU power and memory. Additionally, since the adjacency matrices are full of more zeros than ones, a majority of the multiplications performed are trivial zero multiplications.</p>
<p>One of my early goals for the summer was the conversion of all walk-count (and subsequently, path count) functions to sparse matrices. Sparse matrices, as employed by the Python library SciPy <span class="citation">[<a href="#ref-LsT2mKA3">15</a>]</span>, represent data in matrices which are primarily composed of zeros. The selection of sparse representation and threshold are discussed in the Results section, but sparse matrices warrant a brief description.</p>
<p>In the sparse representation we used, compressed-sparse-column format (CSC), a matrix is stored as three one-dimensional arrays.</p>
<p>Consider the following matrix:</p>
<span class="math display">\[\begin{bmatrix}
4 &amp; 5 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 1 &amp; 0\\
3 &amp; 0 &amp; 0 &amp; 9\\
0 &amp; 6 &amp; 0 &amp; 5
\end{bmatrix}\]</span>
<p>We represent the nonzero elements with one array, with the elements being taken from top to bottom, from left to right.</p>
<span class="math display">\[\begin{bmatrix}
4 &amp; 3 &amp; 5 &amp; 6 &amp; 1 &amp; 9 &amp; 5
\end{bmatrix}\]</span>
<p>Next, we give the row indices of these elements.</p>
<span class="math display">\[\begin{bmatrix}
0 &amp; 2 &amp; 0 &amp; 3 &amp; 1 &amp; 2 &amp; 3
\end{bmatrix}\]</span>
<p>The final array represents what is called a column pointer. This array gives the indices of the first array where each column starts.</p>
<span class="math display">\[\begin{bmatrix}
0 &amp; 2 &amp; 4 &amp; 5 &amp; 7
\end{bmatrix}\]</span>
<p>These three arrays represent the entirety of a matrix.</p>
<h4 id="other-tools">Other tools</h4>
<p>A significant amount of work done later in the summer involved attempting to compare the new functions to the quite slow old functions. As has become relatively standard for much of computational work, we made use of Jupyter notebooks <span class="citation">[<a href="#ref-klbqKLT4">16</a>]</span> to display the code used to run analysis and its output in a re-usable way. Within this, we were able to effectively incorporate the data manipulation and analysis library pandas <span class="citation">[<a href="#ref-iE9hnE2z">17</a>]</span> and the multiprocessing library concurrent.futures <span class="citation">[<a href="#ref-AwSIzjc6">18</a>]</span>. For visualization, we utilized the online service Neo4j to represent Hetionet v1.0 <span class="citation">[<a href="#ref-cagYjYkt">19</a>]</span>, and the Python graphing libraries Matplotlib <span class="citation">[<a href="#ref-118qTQ4yr">20</a>]</span> and seaborn <span class="citation">[<a href="#ref-CyOJLKc2">21</a>]</span>.</p>
<p>The most important tool we used this summer to track progress was the version control software, Git. Our repositories were hosted on the online git hosting service, GitHub <span class="citation">[<a href="#ref-tgH1jNoV">22</a>]</span>. Specifically, every contribution I made this summer can be viewed in detail at my GitHub profile (https://git.io/v5qC9). This will be discussed further in the Results section below.</p>
<h2 id="results">Results</h2>
<p>The main problem towards which I worked this summer was an implementation of the degree-weighted path count. While the degree-weighted <em>walk</em> count is relatively trivial to implement with matrix multiplication, the path count is non-trivial. If computational efficiency is to be considered, each category of metapath will require a different path-count method. As of mid-August 2017, I have merged 7 pull requests into the main Hetmech repository on GitHub, and I have one open development branch. These contributions amounted to 1043 lines added and 264 lines deleted in the repository.</p>
<h3 id="dwpc">DWPC</h3>
<p>I have completed an implementation of the degree-weighted path count (DWPC) in the form of several independent functions. What follows are the specifics of this new method.</p>
<p>When a user calls the <code>dwpc</code> function over a metapath, a series of steps occur before any actual path-counting occurs. First, the metapath is categorized according to its repeated metanodes. For example, the metapath ‘GaDrDaG’, (‘Gene-associates-Disease-resembles-Disease-associates-Gene’) would be classified <code>BAAB</code>. Further examples of this classification method are in Table <a href="#tbl:classification">3</a> below.</p>
<p>Next, the metapath is split into segments according to its classification. This step allowed for the abstraction of metapath patterns to metapaths which followed the pattern of a classification but included randomly inserted, non-repeating metanodes anywhere in the bath. Splitting the metapath essentially allowed us to work with paths like <code>A-B-C-D-B-A</code> in the same way that we work with <code>A-B-B-A</code>, by abstracting any non-repeating metanodes to within segments.</p>
<a name="tbl:classification"></a>
<table>
<caption>Table 3: Example metapaths with classifications and segments </caption>
<thead>
<tr class="header">
<th>Metapath</th>
<th>Classification</th>
<th>Segments</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CbGiGbC</td>
<td>BAAB</td>
<td>CbG; GiG; GbC</td>
</tr>
<tr class="even">
<td>DaGaDaG</td>
<td>BABA</td>
<td>DaG; GaD; DaG</td>
</tr>
<tr class="odd">
<td>DlAeGaDaG</td>
<td>BABA</td>
<td>DlAeG; GaD; DaG</td>
</tr>
<tr class="even">
<td>CrCrC</td>
<td>short_repeat</td>
<td>CrCrC</td>
</tr>
<tr class="odd">
<td>DlAeG</td>
<td>no_repeats</td>
<td>DlAeG</td>
</tr>
<tr class="even">
<td>CrCrCrC</td>
<td>long_repeat</td>
<td>CrCrCrC</td>
</tr>
<tr class="odd">
<td>CbGiGiGaDrDpCpD</td>
<td>interior_complete_group</td>
<td>CbG; GiGiG; GaD; DrD; DpC; CpD</td>
</tr>
</tbody>
</table>
<p>See Figure <a href="#fig:metapath_breakdown">3</a> for a breakdown of all the metapaths according to their categorization.</p>
<div class="figure">
<img src="images/metanodes_by_category.svg" alt="Figure 3: 1170 metapaths by categorization" id="fig:metapath_breakdown" width="480" />
<p class="caption">Figure 3: 1170 metapaths by categorization</p>
</div>
<p>Once the metapath is split into segments, the original metapath classification is used to select the appropriate DWPC function. For example, if the metapath classification is <code>BAAB</code>, then the segmented metapath will be given to the function <code>dwpc_baab</code>.</p>
<p>Each DWPC function has a unique method for ensuring that it outputs a path-count rather than a walk count. For many metapaths this was a non-trivial method to unravel, and often involved several steps of additions, subtractions, multiplications, and normalizations. Our work was greatly aided by the help of the mathematician Dr. Kyle Kloster, with whom we collaborated on some of the more challenging linear algebra algorithms.</p>
<p>In addition to the specific DWPC functions, I created a general method which works over all metapaths, no matter the length. While slower than the other methods, this function allows us to ensure that every path is covered by the DWPC. The method uses a dictionary of history vectors for every index in the matrix and splits computations whenever a path has the opportunity to diverge into multiple potential paths.</p>
<h3 id="calculation-time">Calculation time</h3>
<p>Our new matrix method for calculating DWPC decreased the computation time by 98.5 percent. We reduced the time to compute DWPC over nearly 1200 metepaths from roughly four-and-a-half days to roughly one hour and thirty-seven minutes <span class="citation">[<a href="#ref-1BU7iA21F">23</a>]</span>. One of the major advances we made in our method this summer was the realization that we can calculate the DWPC more efficiently by categorizing each metapath and feeding it to a DWPC function corresponding to a particular metapath category. These specialized functions allow us to increase significantly the speed with which we can make calculations. However, while we were able to reduce almost all computation times, there are a number of metapaths which we cannot calculate significantly more quickly than we could with the old method. 36 of 1206 metapaths had to use the generalized function I wrote which enumerates each path independently using a dictionary of history vectors in order to ensure no nodes are repeated.</p>
<p>For the remaining 1170 metapaths, the corresponding DWPC calculation times are summarized in Figure <a href="#fig:all_metapath_times">4</a>.</p>
<div class="figure">
<img src="images/all_path_time.svg" alt="Figure 4: Matrix method DWPC calculation times for each of 1170 metapaths" id="fig:all_metapath_times" width="480" />
<p class="caption">Figure 4: Matrix method DWPC calculation times for each of 1170 metapaths</p>
</div>
<p>As mentioned, we created a new system whereby metapaths are categorized according to the method we use for computing the DWPC. For example, the metapath ‘CbGbCbGaD’ is classified as <code>BABA</code>, due to the overlapping repeat nature of the metanodes for ‘Compound’ and ‘Gene’. See Figure <a href="#fig:metapath_breakdown">3</a> for a breakdown of all the metapaths according to their categorization.</p>
<p>In trying to reduce runtime, we were constantly trying to optimize every step in our computation. We were able to reduce runtimes significantly using sparse matrices as previously mentioned. The key, however, to a faster computational pipeline was categorizing metapaths and using specialized functions for each metapath. A breakdown of these functions’ performance is in Figure <a href="#fig:category_runtimes">5</a>.</p>
<div class="figure">
<img src="images/category_runtimes.svg" alt="Figure 5: DWPC calculation runtimes by metapath category and path length. In this context, path length indicates the number of edges in the path." id="fig:category_runtimes" width="480" />
<p class="caption">Figure 5: DWPC calculation runtimes by metapath category and path length. In this context, path length indicates the number of edges in the path.</p>
</div>
<p>Finally, in tracing back the slowest calculations, we found that a few metapaths took significantly longer than all others. We discovered that these involved the metapaths with the segment ‘[…]GeAeG[…]’ (see Figure <a href="#fig:gene_times">6</a>).</p>
<div class="figure">
<img src="images/gene_time_breakdown.svg" alt="Figure 6: Breakdown of the slowest metapath computation time by repeated Gene segment. G_X_G is all metapaths which include a segment of three metanodes, whose innermost metanode is not Anatomy. G_A_G is all metapaths with a segment Gene-Anatomy-Gene except those of the form GeAeG. GeAeG is strictly metapaths with the segment corresponding to Gene-expressed-Anatomy-expressed-Gene, meaning that there are two genes expressed in a certain anatomical region. Please note that there is no overlap between any of the three groups. GeAeG is the most specific, and the other two groups do not include it. G_X_G includes neither any of the G_A_G nor of the GeAeG metapaths." id="fig:gene_times" width="480" />
<p class="caption">Figure 6: Breakdown of the slowest metapath computation time by repeated Gene segment. ‘G_X_G’ is all metapaths which include a segment of three metanodes, whose innermost metanode is not ‘Anatomy’. ‘G_A_G’ is all metapaths with a segment ‘Gene’-‘Anatomy’-‘Gene’ except those of the form ‘GeAeG’. ‘GeAeG’ is strictly metapaths with the segment corresponding to ‘Gene-expressed-Anatomy-expressed-Gene’, meaning that there are two genes expressed in a certain anatomical region. Please note that there is no overlap between any of the three groups. ‘GeAeG’ is the most specific, and the other two groups do not include it. ‘G_X_G’ includes neither any of the ‘G_A_G’ nor of the ‘GeAeG’ metapaths.</p>
</div>
<h3 id="multiple-search-capability">Multiple search capability</h3>
<p>As with many graph traversal tasks, using adjacency matrices to calculated DWPC meant that querying a set of nodes has become simpler. Our initial work has been on metapaths starting with compounds and ending with diseases. Having cached our DWPC matrices along every ‘C-[…]-D’ metapath with five or fewer edges, we can extract path counts for multiple queried nodes simply by performing matrix-vector multiplication.</p>
<h3 id="other-summer-results">Other summer results</h3>
<p>I also gained a deeper appreciation of and respect for open-access and collaborative science. In working towards this, I reported a relevant bug in the open source Python repository SciPy which dealt with issues involving matrix multiplication <span class="citation">[<a href="#ref-R0MGiivw">24</a>]</span>.</p>
<p>In the deep learning review paper, I contributed a section on deep learning applications in the field of protein-protein interaction predictions, with a subsection on deep learning methods for the prediction of MHC-peptide binding <span class="citation">[<a href="#ref-otFK6ZiU">25</a>]</span>.</p>
<h2 id="next-steps">Next steps</h2>
<p>We plan to use the functionality created this summer to predict potential targets for drug repurposing. By doing this, we can provide further verification for our path-count method in the same way we did for the original study. Additionally, we can verify the accuracy of our new matrix-formulation by comparing it to the far slower but precise graph method. Yet another method for verifying the predictions of our method involves comparing our predictions to new drugs which are entering the later phases of clinical trial. As these compounds are not in our Hetnet, we would hope to see that later-phase clinical trial drugs score highly in our treatment predictions for their target diseases. Luckily, a description of all such clinical trials– both active and complete in 195 countries– is available on a government website <span class="citation">[<a href="#ref-vbD9t39A">26</a>]</span> run by the National Institutes of Health and the National Library of Medicine.</p>
<p>Now that our methods for traversing the graph are much faster and more expanded, we can add significantly more data into our heterogeneous network. A project is already underway in our lab which hopes to incorporate data mined from biomedical literature through natural language processing into our network. This project is a natural complement to the work I did this summer, because while a bigger graph requires more computation time, the matrix-based DWPC method will scale far better to increased data size than the conventional graph method.</p>
<p>Another use-case for our faster computation method is an increase in considered metapaths. In previous work, we have considered only a subset of the potential metapaths. For one, we only investigated metapaths starting with a compound and ending with a disease. Further, even within compound-disease metapaths, we did not consider all possible paths. Path lengths were constrained to be of length four or fewer edges in the previous work. My work this summer allows us to expand the reach of potential metapaths we consider without sacrificing hugely on performance.</p>
<p>As with many of the open-source projects in the Greene Lab, we hope to eventually create an open-access webserver which can access the results of our method. It should allow a user to search for as many nodes as desired and be returned a set of possible connections between them with corresponding metapaths. If this could be done, the functionality could be expanded to automatically generate a Neo4j query which could show the graphs being described by our predictions.</p>
<p>A final potential step forward involves extracting different features from the graph in order to make predictions about potential connections. Our method utilizes path count which corrects for degree-weight, and it has shown good performance toward predicting targets for drug repurposing. Other measures of connectedness within a graph, or other methods for degree correction could show equal or better performance, though. For example, graph centrality is a measure of the importance of certain vertices in a graph. There are feasible methods which could, for example, correct for graph centrality instead of degree for every node in a path. Even more distant from our current method is one which could incorporate some of the most exciting advances in computer science and statistics like deep learning. In such a method, we would feed a model a large amount of information about each node, and then computationally extract features without human selection. For example, in predicting protein-protein interactions, Du et al. <span class="citation">[<a href="#ref-rVgq22nD">27</a>]</span> used a two-stage deep neural network first to learn the features of individual proteins which are important for predicting their interactions and second to learn the higher-level features of two proteins’ pre-selected features which predict their binding. The best way to test other methods is to split our data into training, validation, and test sets and compare the performance of different methods. In short, there are many additional methods we could employ to make predictions of future graph connections.</p>
<h2 id="conclusion">Conclusion</h2>
<p>This summer I worked in the Greene Lab on implementing a new method for predicting drugs which could be repurposed. I contributed to this goal through several means, including the implementing a new matrix formulation of a graph node connectedness measure called the degree-weighted path count (DWPC). This measure and its new calculation method allows us to make significantly faster (66.8-fold decrease in time) calculations, whose outputs can be used to accurately predict future connections in a graph. In trying to predict compound-disease connections, our work represents a methodological advance from the previously serendipitous nature of discovering drug repurposing targets. I found this summer extremely valuable for this reason, as well as for my personal development. My computational skills have improved considerably, and my depth of understanding in the field of computational biomedical science has grown. We hope that our new method will prove useful to future researchers hoping to quickly and cheaply bring effective drugs to market, and I hope that the skills I gained this summer will be beneficial in a future biomedical research capacity.</p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>Vagelos Scholars Program in Molecular Life Science (MLS)</p>
<p>Greene Lab (http://www.greenelab.com/)</p>
<p>Daniel Himmelstein - Postdoctoral Fellow, Greene Lab</p>
<p>Casey Greene - PI, Greene Lab</p>
<p>Kyle Kloster - Postdoctoral Researcher, North Carolina State University (NCSU)</p>
<p>Michael Mayers - Graduate Student, Scripps Research Institute</p>
<h2 id="citations" class="unnumbered">Citations</h2>
<div id="refs" class="references">
<div id="ref-LlRXV6lE">
<p>1. Scannell JW, Blanckley A, Boldon H, Warrington B. 2012 Diagnosing the decline in pharmaceutical R&amp;D efficiency. <em>Nat Rev Drug Discov</em> <strong>11</strong>, 191–200. See <a href="https://doi.org/10.1038/nrd3681" class="uri">https://doi.org/10.1038/nrd3681</a>.</p>
</div>
<div id="ref-13c9OPizf">
<p>2. DiMasi JA, Grabowski HG, Hansen RW. 2016 Innovation in the pharmaceutical industry: New estimates of R&amp;D costs. <em>Journal of Health Economics</em> <strong>47</strong>, 20–33. See <a href="https://doi.org/10.1016/j.jhealeco.2016.01.012" class="uri">https://doi.org/10.1016/j.jhealeco.2016.01.012</a>.</p>
</div>
<div id="ref-nn9rnuHx">
<p>3. DiMasi JA, Hansen RW, Grabowski HG. 2003 The price of innovation: new estimates of drug development costs. <em>Journal of Health Economics</em> <strong>22</strong>, 151–185. See <a href="https://doi.org/10.1016/s0167-6296(02)00126-1" class="uri">https://doi.org/10.1016/s0167-6296(02)00126-1</a>.</p>
</div>
<div id="ref-269zMv7S">
<p>4. DiMasi JA, Hansen RW, Grabowski HG, Lasagna L. 1991 Cost of innovation in the pharmaceutical industry. <em>Journal of Health Economics</em> <strong>10</strong>, 107–142. See <a href="https://doi.org/10.1016/0167-6296(91)90001-4" class="uri">https://doi.org/10.1016/0167-6296(91)90001-4</a>.</p>
</div>
<div id="ref-z38InjRh">
<p>5. Pammolli F, Magazzini L, Riccaboni M. 2011 The productivity crisis in pharmaceutical R&amp;D. <em>Nat Rev Drug Discov</em> <strong>10</strong>, 428–438. See <a href="https://doi.org/10.1038/nrd3405" class="uri">https://doi.org/10.1038/nrd3405</a>.</p>
</div>
<div id="ref-g5JcTYOY">
<p>6. Schuhmacher A, Gassmann O, Hinder M. 2016 Changing R&amp;D models in research-based pharmaceutical companies. <em>J Transl Med</em> <strong>14</strong>, 105. See <a href="https://www.ncbi.nlm.nih.gov/pubmed/27118048" class="uri">https://www.ncbi.nlm.nih.gov/pubmed/27118048</a>.</p>
</div>
<div id="ref-o8yROPbx">
<p>7. Hay M, Thomas DW, Craighead JL, Economides C, Rosenthal J. 2014 Clinical development success rates for investigational drugs. <em>Nat Biotechnol</em> <strong>32</strong>, 40–51. See <a href="https://doi.org/10.1038/nbt.2786" class="uri">https://doi.org/10.1038/nbt.2786</a>.</p>
</div>
<div id="ref-c7z5BwrM">
<p>8. Nosengo N. 2016 Can you teach old drugs new tricks? <em>Nature</em> <strong>534</strong>, 314–316. See <a href="https://doi.org/10.1038/534314a" class="uri">https://doi.org/10.1038/534314a</a>.</p>
</div>
<div id="ref-X1hJHTyw">
<p>9. greenelab. In press. greenelab/hetmech. <em>GitHub</em>. See <a href="https://github.com/greenelab/hetmech" class="uri">https://github.com/greenelab/hetmech</a>.</p>
</div>
<div id="ref-yLr4pV4G">
<p>10. greenelab. In press. greenelab/deep-review. <em>GitHub</em>. See <a href="https://github.com/greenelab/deep-review" class="uri">https://github.com/greenelab/deep-review</a>.</p>
</div>
<div id="ref-11rVTcUCK">
<p>11. Himmelstein DS, Lizee A, Hessler C, Brueggeman L, Chen SL, Hadley D, Green A, Khankhanian P, Baranzini SE. 2016 Systematic integration of biomedical knowledge prioritizes drugs for repurposing. See <a href="https://doi.org/10.1101/087619" class="uri">https://doi.org/10.1101/087619</a>.</p>
</div>
<div id="ref-w4Mi034s">
<p>12. Weisstein EW. In press. Adjacency Matrix. <em>MathWorld–A Wolfram Web Resource</em>. See <a href="http://mathworld.wolfram.com/AdjacencyMatrix.html" class="uri">http://mathworld.wolfram.com/AdjacencyMatrix.html</a>.</p>
</div>
<div id="ref-WkPlH1ds">
<p>13. Himmelstein DS, Baranzini SE. 2015 Heterogeneous Network Edge Prediction: A Data Integration Approach to Prioritize Disease-Associated Genes. <em>PLoS Comput Biol</em> <strong>11</strong>, e1004259. See <a href="https://doi.org/10.1371/journal.pcbi.1004259" class="uri">https://doi.org/10.1371/journal.pcbi.1004259</a>.</p>
</div>
<div id="ref-eye5ay6P">
<p>14. numpy. In press. numpy/numpy. <em>GitHub</em>. See <a href="https://github.com/numpy/numpy" class="uri">https://github.com/numpy/numpy</a>.</p>
</div>
<div id="ref-LsT2mKA3">
<p>15. scipy. In press. scipy/scipy. <em>GitHub</em>. See <a href="https://github.com/scipy/scipy" class="uri">https://github.com/scipy/scipy</a>.</p>
</div>
<div id="ref-klbqKLT4">
<p>16. jupyter. In press. jupyter/notebook. <em>GitHub</em>. See <a href="https://github.com/jupyter/notebook" class="uri">https://github.com/jupyter/notebook</a>.</p>
</div>
<div id="ref-iE9hnE2z">
<p>17. pandas-dev. In press. pandas-dev/pandas. <em>GitHub</em>. See <a href="https://github.com/pandas-dev/pandas" class="uri">https://github.com/pandas-dev/pandas</a>.</p>
</div>
<div id="ref-AwSIzjc6">
<p>18. 2017 17.4. concurrent.futures — Launching parallel tasks — Python 3.6.2 documentation. See <a href="https://docs.python.org/3/library/concurrent.futures.html" class="uri">https://docs.python.org/3/library/concurrent.futures.html</a>.</p>
</div>
<div id="ref-cagYjYkt">
<p>19. Technology N. 2017 Hetionet · Neo4j Browser. See <a href="https://neo4j.het.io/browser/" class="uri">https://neo4j.het.io/browser/</a>.</p>
</div>
<div id="ref-118qTQ4yr">
<p>20. matplotlib. In press. matplotlib/matplotlib. <em>GitHub</em>. See <a href="https://github.com/matplotlib/matplotlib" class="uri">https://github.com/matplotlib/matplotlib</a>.</p>
</div>
<div id="ref-CyOJLKc2">
<p>21. 2017 seaborn: statistical data visualization — seaborn 0.8.0 documentation. See <a href="https://seaborn.pydata.org/" class="uri">https://seaborn.pydata.org/</a>.</p>
</div>
<div id="ref-tgH1jNoV">
<p>22. In press. Greene Laboratory. <em>GitHub</em>. See <a href="https://github.com/greenelab" class="uri">https://github.com/greenelab</a>.</p>
</div>
<div id="ref-1BU7iA21F">
<p>23. dhimmel. In press. dhimmel/learn. <em>GitHub</em>. See <a href="https://github.com/dhimmel/learn/blob/master/all-features/3-extract.ipynb" class="uri">https://github.com/dhimmel/learn/blob/master/all-features/3-extract.ipynb</a>.</p>
</div>
<div id="ref-R0MGiivw">
<p>24. scipy. In press. Operations between numpy.array and scipy.sparse matrix return inconsistent array type · Issue #7510 · scipy/scipy. <em>GitHub</em>. See <a href="https://github.com/scipy/scipy/issues/7510" class="uri">https://github.com/scipy/scipy/issues/7510</a>.</p>
</div>
<div id="ref-otFK6ZiU">
<p>25. greenelab. In press. Added PPI section with MHC subsection by zietzm · Pull Request #638 · greenelab/deep-review. <em>GitHub</em>. See <a href="https://github.com/greenelab/deep-review/pull/638" class="uri">https://github.com/greenelab/deep-review/pull/638</a>.</p>
</div>
<div id="ref-vbD9t39A">
<p>26. In press. Home - ClinicalTrials.gov. See <a href="https://clinicaltrials.gov/" class="uri">https://clinicaltrials.gov/</a>.</p>
</div>
<div id="ref-rVgq22nD">
<p>27. Du X, Sun S, Hu C, Yao Y, Yan Y, Zhang Y. 2017 DeepPPI: Boosting Prediction of Protein–Protein Interactions with Deep Neural Networks. <em>J. Chem. Inf. Model.</em> <strong>57</strong>, 1499–1510. See <a href="https://doi.org/10.1021/acs.jcim.7b00028" class="uri">https://doi.org/10.1021/acs.jcim.7b00028</a>.</p>
</div>
</div>
<script>
// AnchorJS minified version below.
// Source https://github.com/bryanbraun/anchorjs/blob/064abdd0987f305933ec4982af6d0c1cf2fd0814/anchor.js

/**
 * AnchorJS - v4.0.0 - 2017-06-02
 * https://github.com/bryanbraun/anchorjs
 * Copyright (c) 2017 Bryan Braun; Licensed MIT
 */
!function(A,e){"use strict";"function"==typeof define&&define.amd?define([],e):"object"==typeof module&&module.exports?module.exports=e():(A.AnchorJS=e(),A.anchors=new A.AnchorJS)}(this,function(){"use strict";function A(A){function e(A){A.icon=A.hasOwnProperty("icon")?A.icon:"",A.visible=A.hasOwnProperty("visible")?A.visible:"hover",A.placement=A.hasOwnProperty("placement")?A.placement:"right",A.class=A.hasOwnProperty("class")?A.class:"",A.truncate=A.hasOwnProperty("truncate")?Math.floor(A.truncate):64}function t(A){var e;if("string"==typeof A||A instanceof String)e=[].slice.call(document.querySelectorAll(A));else{if(!(Array.isArray(A)||A instanceof NodeList))throw new Error("The selector provided to AnchorJS was invalid.");e=[].slice.call(A)}return e}function n(){if(null===document.head.querySelector("style.anchorjs")){var A,e=document.createElement("style");e.className="anchorjs",e.appendChild(document.createTextNode("")),void 0===(A=document.head.querySelector('[rel="stylesheet"], style'))?document.head.appendChild(e):document.head.insertBefore(e,A),e.sheet.insertRule(" .anchorjs-link {   opacity: 0;   text-decoration: none;   -webkit-font-smoothing: antialiased;   -moz-osx-font-smoothing: grayscale; }",e.sheet.cssRules.length),e.sheet.insertRule(" *:hover > .anchorjs-link, .anchorjs-link:focus  {   opacity: 1; }",e.sheet.cssRules.length),e.sheet.insertRule(" [data-anchorjs-icon]::after {   content: attr(data-anchorjs-icon); }",e.sheet.cssRules.length),e.sheet.insertRule(' @font-face {   font-family: "anchorjs-icons";   src: url(data:n/a;base64,AAEAAAALAIAAAwAwT1MvMg8yG2cAAAE4AAAAYGNtYXDp3gC3AAABpAAAAExnYXNwAAAAEAAAA9wAAAAIZ2x5ZlQCcfwAAAH4AAABCGhlYWQHFvHyAAAAvAAAADZoaGVhBnACFwAAAPQAAAAkaG10eASAADEAAAGYAAAADGxvY2EACACEAAAB8AAAAAhtYXhwAAYAVwAAARgAAAAgbmFtZQGOH9cAAAMAAAAAunBvc3QAAwAAAAADvAAAACAAAQAAAAEAAHzE2p9fDzz1AAkEAAAAAADRecUWAAAAANQA6R8AAAAAAoACwAAAAAgAAgAAAAAAAAABAAADwP/AAAACgAAA/9MCrQABAAAAAAAAAAAAAAAAAAAAAwABAAAAAwBVAAIAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAMCQAGQAAUAAAKZAswAAACPApkCzAAAAesAMwEJAAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAAAAAAAAAAAAAQAAg//0DwP/AAEADwABAAAAAAQAAAAAAAAAAAAAAIAAAAAAAAAIAAAACgAAxAAAAAwAAAAMAAAAcAAEAAwAAABwAAwABAAAAHAAEADAAAAAIAAgAAgAAACDpy//9//8AAAAg6cv//f///+EWNwADAAEAAAAAAAAAAAAAAAAACACEAAEAAAAAAAAAAAAAAAAxAAACAAQARAKAAsAAKwBUAAABIiYnJjQ3NzY2MzIWFxYUBwcGIicmNDc3NjQnJiYjIgYHBwYUFxYUBwYGIwciJicmNDc3NjIXFhQHBwYUFxYWMzI2Nzc2NCcmNDc2MhcWFAcHBgYjARQGDAUtLXoWOR8fORYtLTgKGwoKCjgaGg0gEhIgDXoaGgkJBQwHdR85Fi0tOAobCgoKOBoaDSASEiANehoaCQkKGwotLXoWOR8BMwUFLYEuehYXFxYugC44CQkKGwo4GkoaDQ0NDXoaShoKGwoFBe8XFi6ALjgJCQobCjgaShoNDQ0NehpKGgobCgoKLYEuehYXAAAADACWAAEAAAAAAAEACAAAAAEAAAAAAAIAAwAIAAEAAAAAAAMACAAAAAEAAAAAAAQACAAAAAEAAAAAAAUAAQALAAEAAAAAAAYACAAAAAMAAQQJAAEAEAAMAAMAAQQJAAIABgAcAAMAAQQJAAMAEAAMAAMAAQQJAAQAEAAMAAMAAQQJAAUAAgAiAAMAAQQJAAYAEAAMYW5jaG9yanM0MDBAAGEAbgBjAGgAbwByAGoAcwA0ADAAMABAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAH//wAP) format("truetype"); }',e.sheet.cssRules.length)}}this.options=A||{},this.elements=[],e(this.options),this.isTouchDevice=function(){return!!("ontouchstart"in window||window.DocumentTouch&&document instanceof DocumentTouch)},this.add=function(A){var i,o,s,c,r,a,h,l,u,d,f,g,p=[];if(e(this.options),"touch"===(g=this.options.visible)&&(g=this.isTouchDevice()?"always":"hover"),A||(A="h2, h3, h4, h5, h6"),0===(i=t(A)).length)return this;for(n(),o=document.querySelectorAll("[id]"),s=[].map.call(o,function(A){return A.id}),r=0;r<i.length;r++)if(this.hasAnchorJSLink(i[r]))p.push(r);else{if(i[r].hasAttribute("id"))c=i[r].getAttribute("id");else if(i[r].hasAttribute("data-anchor-id"))c=i[r].getAttribute("data-anchor-id");else{u=l=this.urlify(i[r].textContent),h=0;do{void 0!==a&&(u=l+"-"+h),a=s.indexOf(u),h+=1}while(-1!==a);a=void 0,s.push(u),i[r].setAttribute("id",u),c=u}d=c.replace(/-/g," "),(f=document.createElement("a")).className="anchorjs-link "+this.options.class,f.href="#"+c,f.setAttribute("aria-label","Anchor link for: "+d),f.setAttribute("data-anchorjs-icon",this.options.icon),"always"===g&&(f.style.opacity="1"),""===this.options.icon&&(f.style.font="1em/1 anchorjs-icons","left"===this.options.placement&&(f.style.lineHeight="inherit")),"left"===this.options.placement?(f.style.position="absolute",f.style.marginLeft="-1em",f.style.paddingRight="0.5em",i[r].insertBefore(f,i[r].firstChild)):(f.style.paddingLeft="0.375em",i[r].appendChild(f))}for(r=0;r<p.length;r++)i.splice(p[r]-r,1);return this.elements=this.elements.concat(i),this},this.remove=function(A){for(var e,n,i=t(A),o=0;o<i.length;o++)(n=i[o].querySelector(".anchorjs-link"))&&(-1!==(e=this.elements.indexOf(i[o]))&&this.elements.splice(e,1),i[o].removeChild(n));return this},this.removeAll=function(){this.remove(this.elements)},this.urlify=function(A){var t=/[& +$,:;=?@"#{}|^~[`%!'<>\]\.\/\(\)\*\\]/g;return this.options.truncate||e(this.options),A.trim().replace(/\'/gi,"").replace(t,"-").replace(/-{2,}/g,"-").substring(0,this.options.truncate).replace(/^-+|-+$/gm,"").toLowerCase()},this.hasAnchorJSLink=function(A){var e=A.firstChild&&(" "+A.firstChild.className+" ").indexOf(" anchorjs-link ")>-1,t=A.lastChild&&(" "+A.lastChild.className+" ").indexOf(" anchorjs-link ")>-1;return e||t||!1}}return A});

// Enable links for selected headers
var anchors = new AnchorJS();
anchors.add("h2, h3, h4")
</script>
</body>
</html>
